# Schedlab 报告

姓名：冉兴嵘
学号：2023200446

## Part A: 思路简述

<!-- 200字以内简述你的Shell实现思路,重点说明:
1. 核心方法的流程，依次做了什么
2. 关键数据结构的设计，如何组织和管理作业控制
-->
本次实验实现了一个基于优先级和截止时间的任务调度策略，来处理 CPU 和 IO 任务的调度，核心思路如下：
通过将任务分为 CPU 任务和 IO 任务，分别存储在两个优先级队列（cpuTodo 和 ioTodo）中来实现任务分类与优先级管理。优先级队列根据任务的优先级和截止时间进行排序，优先级低的排在前面，若优先级相同，则截止时间晚的排在前面。
系统根据当前时间和任务截止时间，从优先级队列中选择合适的任务分配给 CPU 或 IO 执行，确保任务在不同队列之间正确转移（如从 CPU 队列到 IO 队列），并在任务完成时从队列中移除。

## Part B: 具体实现分析


使用 priority_queue<Event::Task, vector<Event::Task>, CompareTask> 实现 cpuTodo 和 ioTodo的优先级队列

自定义比较器 CompareTask，定义排序规则：
优先级不同时，优先级低的（kLow）优先，
优先级相同时，截止时间晚的优先（deadline > deadline）。

2. 核心函数分析
processTaskArrival：
将新到达的任务加入 cpuTodo 队列。

processTaskCompletion：
根据任务 ID，从 cpuTodo 和 ioTodo 中移除已完成任务。

processIoRequest：
将发起 IO 请求的任务从 cpuTodo 移除，加入 ioTodo。

processIoEnd：
将 IO 完成的任务从 ioTodo 移除，重新加入 cpuTodo。

removeTaskFromQueue：
从优先级队列中移除指定任务 ID 的任务。由于 priority_queue 不支持直接删除，采用临时向量存储非目标任务，再重新入队。

policy：
主调度函数，处理事件列表并返回调度决策：
遍历事件，根据类型调用相应处理函数，更新 nowTime 和队列状态。

根据队列状态选择任务：
如果队列非空且队首任务截止时间已到（deadline <= nowTime），优先调度。

否则，调度队首任务。

返回 Action，包含分配的 CPU 和 IO 任务 ID。

## Part C: 关键难点解决
<!-- 选择2-3个最有技术含量的难点:
1. 具体难点描述
2. 你的解决方案
3. 方案的效果
示例难点:
- 作业控制实现
- 信号处理的边界情况
- 管道与重定向的结合
-->
1.从优先级队列中移除任务
priority_queue 不支持直接删除任意元素，但是任务完成或状态迁移需要移除特定任务。
解决方案：
实现 removeTaskFromQueue 函数：
将队列元素弹出，存入临时向量 temp，跳过目标任务，将临时向量中的任务重新入队。

缺点是时间复杂度为 O(n log n)，n 为队列大小，但由于优先级队列的特性，这是必要折衷。

2. 任务状态管理
问题：任务在 CPU 和 IO 队列间频繁迁移，需确保状态一致性（如避免重复入队或漏删）。

解决方案：
在 processIoRequest 和 processIoEnd 中，严格执行“移除-添加”操作，确保任务只出现在一个队列中。

同时 processTaskCompletion 中，同时检查两个队列，防止遗漏。

假设任务 ID 唯一，依赖 taskId 进行匹配和移除。



## Part D: 实验反馈
<!-- 你的反馈对我们至关重要
可以从实验设计，实验文档，框架代码三个方面进行反馈，具体衡量：
1. 实验设计：实验难度是否合适，实验工作量是否合理，是否让你更加理解Shell，Shell够不够有趣
2. 实验文档：文档是否清晰，哪些地方需要补充说明
3. 框架代码：框架代码是否易于理解，接口设计是否合理，实验中遇到的框架代码的问题（请引用在 repo 中你提出的 issue）
-->
这次lab相对不是很难（？），感觉测试也没有用到很多不同策略
